\documentclass{article}
\usepackage{quoting}
\usepackage{datetime}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\setcounter{secnumdepth}{4}
\date{\today \\ \currenttime} 
\title{Sistemas Distribuídos}
\author{Pedro Brito}


\begin{document}
\maketitle

\section{Caso mais simples}

\textbf{Sincronização interna entre dois processos num sistema distribuído síncrono.}


\begin{itemize}
    \item São conhecidos os limites máximo (max) e mínimo (min) para o envio de mensagens, assim como para o desvio do relógio e para o tempo de execução dos processos.
\end{itemize}



\textbf{Assumindo que o processo 1 envia uma mensagem ao processo 2 com o tempo que marca o relógio, t. Temos que : }


\begin{itemize}
    \item A incerteza no envio da mensagem será \textit{u = (Max - Min}
    
    
    \item Se o processo 2 acerta o seu relógio para t + Max, o \textbf{máximo desvio} será também \textbf{u} porque a mensagem pode ter demorado Min.
    
    
    
    \item Mas se o processo 2 acertar o seu relógio para, t + (Max - Min) / 2 então o desvio entre os dois relógios será no máximo, (Max - Min) /2.
\end{itemize}



\section{Como acertar um relógio ? }

Obter UTC e corrigir o software do relógio.



\subsection{Problemas}


\begin{itemize}
    \item O tempo nunca anda para trás.
    \item O valor lido do relógio físico deverá ser escalado pelo software de forma a ir atrasando lentamente, crescente.
    
\end{itemize}



\subsection{Sistemas Assíncronos - Algoritmo de Cristian}


\begin{itemize}
    \item Obter UTC e corrigir o software to relógio.
    
    \item Calcular a estimativa para o tempo de propagação da mensagem
    
    \item p = (T1 - T0 - h) / 2
    
    
    \item Acertar o relógio do cliente para UTC + p 
    
    
    \item Fazer várias medições para obter o valor de T1 - T0
    \begin{itemize}
        \item Descartar valores acima de um determinado limite
        \item Ou assumir os valores mínimos
    \end{itemize}
    
\end{itemize}



\subsection{Algoritmo probabilístico : }

\begin{itemize}
    \item a sincronização é conseguida se o RTT é pequeno quando comparado com a exatidão desejada
    \item a exactidão é tanto maior quanto o tempo de transmissão está perto do mínimo
\end{itemize}



\textbf{Problema}

\begin{itemize}
    \item Ponto único de falha e congestionamento ( bottleneck)

\end{itemize}

\textbf{Solução}
\begin{itemize}
    \item Utilizar um conjunto de servidores com receptores de UTC 
    \item O cliente faz o pedido em multicast para o conjunto de servidores e usa a primeira resposta que recebe
\end{itemize}



\textbf{Problema}

\begin{itemize}
    \item Um servidor em falha ou malicioso pode provocar estragos.

\end{itemize}

\textbf{Solução}
\begin{itemize}
    \item Autenticação 

    \item Protocolo de acordo entre vários servidores que permita mascarar falhas. 
\end{itemize}




\section{Algoritmo de Berkeley  (sincronização interna)}



\begin{itemize}
    \item É escolhido um computador para ser o co-ordenador (master)
    
    \item O master periodicamente contacta os outros computadores (slaves)
    
    \item O master faz uma estimativa do tempo local de cada slave,baseado no rtt.
    
    \item O master calcula o tempo médio de todos os computadores, ignorando valores de transmissão demasiado elevados e máquinas com tempos muito diferentes dos outros.
    
    \item Finalmente o master envia a cada computador o valor de que o seu relógio deve ser ajustado (esse valor pode ser positivo ou negativo)
\end{itemize}

\textbf{Propriedas}

\begin{itemize}
    \item Precisão: depende do round trip time
    \item  Ignora mensagens cujo tempo de transmissão é demasiado elevado.
    \item Que fazer se o master falha? Eleger um novo coordenador. 
\end{itemize}


\section{Modos de sincronização do NTP}

\section{Netowork Time Protocol ( NTP) }

\begin{itemize}
    \item Múltiplos servidores de tempo espalhados pela Internet
    \item Servidores primários (ligados directamente aos receptores de UTC
    \item Servidores secundários sincronizam com os primários
    \item Servidores terciários sincronizam com secundários, etc
    \item  Permite sincronizar um elevado número de máquinas
    \item Permite lidar com avarias de servidores 
        Ou seja : 
        Se um servidor secundário não consegue aceder a um primário, tenta aceder a outro. Existem servidores redundantes e caminhos redundantes entre servidores.
        
    \item Usa autenticação para verificar se a informação vem de fonte fiável
    
\end{itemize}


\section{Modos de Sincronização do NTP }

\subsubsection{Modo "multicast"}
\begin{itemize}
    \item Usado em LANs de alta velocidade
    \item Um ou mais servidores faz periodicamente multicast do seu tempo para os outros servidores. 
    \item Os receptores acertam os seus relógios assumindo um pequeno atraso de transmissão. 
\end{itemize}


\subsubsection{Modo "procedure call"}
\begin{itemize}
    \item Similar ao algoritmo de Cristian
    \item Clientes solicitam o tempo de um ou vários servidores, e estes enviam o valor do seu relógio. 
    \item Adequado quando o multicast não está disponível
\end{itemize}



\subsubsection{Modo "symmetric"}

\textbf{ Maior exactidão, usado em servidores primários ou próximos}


\par 

Para cada par de processos calcula-se um \textit{offset}, \textbf{o}, que corresponde à diferença entre os dois relógios, e um delay, \textbf{d}, que é o tempo total de transmissão das duas mensagens.


Se o offset do relógio de A em relação ao de B for \textbf{o} ( Tb = Ta + \textbf{o}) os tempos de transmissão de mensagens de \textbf{m} e \textbf{m'} forem \textbf{t} e \textbf{t'}.

\par 
Temos então que : 
\par

\begin{equation}
    T_{2}  = T_{1} + t + o
\end{equation}

E

\begin{equation}
    T_{4} = T_{3} + t' - o
\end{equation}


\textbf{Round Trip Delay}
\begin{equation}
    d_{i} = t + t'  = T_{2} - T_{1} + T_{4} - T_{3}
\end{equation}

\textbf{Supondo que T2 - T1 = T4 - T3 então : }

\begin{equation}
    O = T_{3} + (( T_{2} - T_{1}) + ( T_{4} - T_{3})) / 2  - T_{4} = (( T_{2} - T_{1}) + ( T_{3} - T_{4}))/ 2
\end{equation}


\textbf{Se o relógio de A é mais rápido, O < 0 }



\end{document}